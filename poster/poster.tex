\documentclass[a0,landscape]{a0poster}
\input{preamble.tex} % after the basics
\definecolor{PMS310C}{RGB}{62,192,197} % Official MTU colorway

\begin{document}
\begin{tikzpicture}[remember picture,overlay]
  \node[anchor=north east, xshift=-5mm, yshift=-5mm] 
    at (current page.north east) {\includegraphics[height=7cm]{logo.png}};
\end{tikzpicture}

%----------------------------------------------------------------------------------------
% HEADER
%----------------------------------------------------------------------------------------
\vspace*{-2cm} % reduce magnitude if anything touches the top edge

{\setlength{\tabcolsep}{0pt}%
\renewcommand{\arraystretch}{1.05}%

\noindent
\begin{minipage}[t]{0.34\textwidth}
  {\Huge\bfseries\color{PMS310C} Fast Julia}\\[1ex]
  {\Large\itshape Optimizing Dense Systems of ODEs}\\[2ex]
  {\large Daniel Henderson}\\
  {\normalsize Michigan Technological University}\\
  {\small\ttfamily dphender@mtu.edu}
\end{minipage}%
\begin{minipage}[t]{0.24\textwidth}\vspace{0pt}
{\Large\textbf{Abstract}}
{\normalsize
We compare naïve and optimized Julia implementations for solving
small to moderate systems of (ODEs), $\vx'(t) = \vf(\vx, t)$ with
$\dim(\vx) \leq 10^2$. We demonstrate how to asses and resolve performance 
bottlenecks using the Rössler system as a case study. Numerical Experiments
show that a sequence of targeted changes—in-place updates, type stability—can
yield C-like performance while preserving code clarity.
\red{\textbf{<Closing statement describing the basis of our claim; add a key result here.>}}}
\end{minipage}
}

\vspace{0.20cm}
\hrulefill
\vspace{0.20cm}

%----------------------------------------------------------------------------------------
% BODY (3 COLUMNS)
%----------------------------------------------------------------------------------------
\begin{paracol}{3}
  \setcolumnwidth{0.28\textwidth,0.44\textwidth,0.28\textwidth}

%------------------------ INTRODUCTION ------------------------
\section*{Introduction}

\noindent
ODE workflows often involve ensembles: many solves across parameters, initial conditions,
or time horizons. In that regime, per-call overhead in the SciML RHS
$f!(\vu, \vx, \vp, t)$—especially allocations—dominates and can make otherwise
simple experiments impractically slow.”

\medskip

\noindent
Targeted changes to model code-—in-place updates, type stability, and
stack-vs.-heap allocations, etc. combined with the right choice of solver can
yield order-of-magnitude speedups while keeping the code readable and
extensible. In our case, we achieve a \red{XX} speedup from a naïve to an 
optimized Julia implementation of the Rössler ODE system:
\begin{flalign*}
  \tag{Rössler} \label{eq:rossler}
  \quad \vx'(t) = \vf(\vx,\, \vp, \, t) = 
  \vect{
    -x_2 \,-\, x_3 \\
    x_1 \,+\, a x_2 \\
    b \,+\, x_3 (x_1 \,-\, c) \\
  }
    ~ : ~ \begin{cases*}
    \vx = (x_1, \, x_2, \, x_3)^\top \text{ (state variables)}\\
    \vp = (a, \, b, \, c)^\top \text{ (parameters)} 
  \end{cases*}, &&
\end{flalign*}

\medskip

\noindent
We seek $\vx(t)$ for all $t \in [t_0, t_f]$ subject to the initial condition $\vx(t_0)=\vx_0$, with fixed
parameters $\vp$. ``Production'' performance is achieved using \texttt{DifferentialEquations.jl} from the SciML
ecosystem \cite{DifferentialEquations.jl-2017}, building on the SciML techniques
\cite{SciMLTutorial} for optimizing the model code $\vf$.

\medskip

\noindent
\textbf{Case Study.}  We compare out-of-place and in-place Julia implementations
of the Rössler system \eqref{eq:rossler}, together with a type-stable fixed/static-size variant:
\begin{itemize}
  \item naïve out-of-place code allocates a new array at each right-hand-side call, triggering garbage collection;
  \item optimized in-place code eliminates per-call allocations for \texttt{Vector}-based states; and
  \item a \texttt{StaticArrays.jl}/\texttt{SVector} implementation enables stack allocation, often fastest for very small systems.
\end{itemize}
  \textbf{Performance ladder highlights.}
  \begin{itemize}
    \item \texttt{StaticArrays} keep the three-state RHS on the stack, reducing heap pressure and GC noise.
    \item Fixed-size math improves cache locality and throughput for tight ODE kernels.
    \item \texttt{@inbounds} removes bounds checks once dimensions are known at compile time.
    \item \texttt{@inline} encourages the compiler to fuse the RHS into the solver loop, trimming call overhead.
    \item Fewer checks and calls leave the CPU focused on arithmetic in the hot loop.
  \end{itemize}
  We optimize each implementation using macros \texttt{\@inbounds}, \texttt{\@inline}, and we see
  the lowered code to understand the impact of these changes.

\medskip

\medskip
\hrulefill
\medskip

% --- Figure: Pipeline Overview (TikZ) ---
\medskip

\section*{Case Study: Optimizing the Rössler ODE System}

\noindent
\begin{minipage}{\linewidth}
\centering
\begin{minipage}[t]{0.475\linewidth} % Left: out-of-place
\begin{lstlisting}[
  language=Julia,
  linewidth=\linewidth,
  breaklines=true,
  caption={Out-of-place RHS using the SciML interface `f(u,p,t)` (returns a fresh array).},
  label={lst:naive-out-of-place}
]
function rossler(u, p, t)
    du1 = -u[2] - u[3]
    du2 =  u[1] + p[1] * u[2]
    du3 =  p[2] + u[3] * (u[1] - p[3])
    return [du1, du2, du3]
end
\end{lstlisting}
\td{\small \texttt{@allocated rossler([1.0,1.0,1.0], (0.1,0.1,12), 0.0)}
  reports 240 bytes per call (typical).}
\end{minipage}
\hfill
\begin{minipage}[t]{0.475\linewidth} % Right: in-place
\begin{lstlisting}[
  language=Julia,
  linewidth=\linewidth,
  breaklines=true,
  caption={In-place RHS using the SciML signature `f!(du,u,p,t)`.  Avoids per-call allocations and is typically fastest for `Vector`-based states.},
  label={lst:in-place}
]
function rossler!(du, u, p, t)
    x1 = u[1]
    du[1] = -u[2] - u[3]
    du[2] =  x1 + p[1] * u[2]
    du[3] =  p[2] + u[3] * (x1 - p[3])
    return nothing
end
\end{lstlisting}
\end{minipage}
\vspace{0.75em}
\begin{lstlisting}[
  language=Julia,
  linewidth=\linewidth,
  breaklines=true,
  caption={Fixed-size, stack-allocated version using \texttt{StaticArrays}.},
  label={lst:static}
]
function rossler_static(u, p, t)
    x1 = u[1]
    du1 = -u[2] - u[3]
    du2 =  x1 + p[1] * u[2]
    du3 =  p[2] + u[3] * (x1 - p[3])
    return @SVector [du1, du2, du3]
end
\end{lstlisting}
\end{minipage}
% --- END FIRST COLUMN
\switchcolumn

% ------------------------ Middle Column ------------------------


\noindent
\subsection*{Results and Analysis}

% --- Figures: speedup plot ---
\noindent
\begin{minipage}{\linewidth}
\centering
\begin{minipage}[t]{0.475\linewidth} % Left figure
  \includegraphics[width=0.95\linewidth]{rk4_time_normalized_log10.png}
  {\captionsetup{hypcap=false}%
  \captionof{figure}{Solve-time speedup for Rössler RHS variants relative to the naïve out-of-place baseline `rossler\_naive`, using $\text{speedup}=\mathrm{median\_time}(\texttt{rossler\_naive})/\mathrm{median\_time}(\text{variant})$.}}
\end{minipage}
\hfill
\begin{minipage}[t]{0.475\linewidth} % Right figure
  \includegraphics[width=0.95\linewidth]{rk4_time_normalized_log10.png}
  {\captionsetup{hypcap=false}%
  \captionof{figure}{Solve-time bar chart normalized against the same `rossler\_naive` baseline, highlighting the six core ladder functions and using the speedup definition $\mathrm{median\_time}(\texttt{rossler\_naive})/\mathrm{median\_time}(\text{variant})$.}}
\end{minipage}
\end{minipage}
% --- Table placeholder: benchmark numbers ---
\begin{center}
  \begin{tabular}{lccc}
    \toprule
    \textbf{Method} & \textbf{Runtime (rel.)} & \textbf{Allocations (rel.)} & \textbf{Speedup} \\
    \midrule
    Naïve Julia      & 1.00 & 1.00 & $1.0\times$ \\
    Optimized Julia  & 0.12 & 0.05 & $8.3\times$ \\
    SciML baseline   & 0.10 & 0.04 & $10.0\times$ \\
    \bottomrule
  \end{tabular}
  {\captionsetup{hypcap=false}%
  \captionof{table}{Relative runtime, allocations and speedup, where speedup is always computed as $\mathrm{median\_time}(\texttt{rossler\_naive})/\mathrm{median\_time}(\text{variant})$ to keep the naïve out-of-place implementation as the baseline.}}
\end{center}

\medskip
\hrulefill
\medskip

% --- END MIDDLE COLUMN
\switchcolumn

% ---- TODO WHAT GOES HERE? --- Conclusion comes last
%------------------------ Conclusion ------------------------
\section*{Conclusion: Optimizing ODEs in Julia}

\noindent
Symbolic computation can automate derivations and optimizations that would otherwise
be performed manually, improving both performance and reliability.  For example, the 
Rössler system \eqref{eq:rossler} is linear in two unknowns and can be simplified by 
substitution; \texttt{ModelingToolkit.jl} can automate this process and generates 
optimized code for the resulting system.

\medskip

\noindent
By carefully crafting our Julia implementation—using in-place updates, 
static arrays and solver-aware techniques—we achieved C-like performance 
without sacrificing code clarity.  Eliminating unnecessary allocations and 
choosing the right data layout allow simulation code to scale up to large problems,
be reused in future research and be shared confidently with the community.

\medskip

\noindent
Choosing the right integrator is crucial: an explicit scheme is sufficient for 
the non-stiff Rössler system, but implicit methods are necessary for stiff problems.
The SciML ecosystem provides a rich set of tools for selecting and tuning the best 
solver for your problem; don’t guess—measure with \texttt{BenchmarkTools.jl}!

\medskip

\noindent
%------------------------ REFERENCES ------------------------
\nocite{*}
\bibliographystyle{plain}
\bibliography{mybib}

\end{paracol}
\end{document}