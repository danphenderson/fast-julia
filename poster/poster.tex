\documentclass[a0,landscape]{a0poster}
\input{preamble.tex} % after the basics
\definecolor{PMS310C}{RGB}{62,192,197} % Official MTU colorway

\begin{document}
\begin{tikzpicture}[remember picture,overlay]
  \node[anchor=north east, xshift=-5mm, yshift=-5mm] 
    at (current page.north east) {\includegraphics[height=7cm]{logo.png}};
\end{tikzpicture}

%----------------------------------------------------------------------------------------
% HEADER
%----------------------------------------------------------------------------------------
\vspace*{-2cm} % reduce magnitude if anything touches the top edge

{\setlength{\tabcolsep}{0pt}%
\renewcommand{\arraystretch}{1.05}%

\noindent
\begin{minipage}[t]{0.34\textwidth}
  {\Huge\bfseries\color{PMS310C} Fast Julia}\\[1ex]
  {\Large\itshape Optimizing Dense Systems of ODEs}\\[2ex]
  {\large Daniel Henderson}\\
  {\normalsize Michigan Technological University}\\
  {\small\ttfamily dphender@mtu.edu}
\end{minipage}%
\begin{minipage}[t]{0.24\textwidth}\vspace{0pt}
{\Large\textbf{Abstract}}
{\normalsize
We compare naïve and optimized Julia implementations for solving
small to moderate systems of (ODEs), $\vx'(t) = \vf(\vx, t)$ with
$\dim(\vx) \leq 10^2$. We demonstrate how to asses and resolve performance 
bottlenecks using the Rössler system as a case study. Numerical Experiments
show that a sequence of targeted changes—in-place updates, type stability—can
yield C-like performance while preserving code clarity.
\red{\textbf{<Closing statement describing the basis of our claim; add a key result here.>}}}
\end{minipage}
}

\vspace{0.20cm}
\hrulefill
\vspace{0.20cm}

%----------------------------------------------------------------------------------------
% BEGIN: BODY (3 COLUMNS)
%----------------------------------------------------------------------------------------
\begin{paracol}{3}
  \setcolumnwidth{0.28\textwidth,0.44\textwidth,0.28\textwidth}

%----------------------------------------------------------------------------------------
% BEGIN: LEFT COLUMN
%----------------------------------------------------------------------------------------
\section*{Introduction}

\noindent
\td{
  \textbf{Add Figure:} The Rössler attractor visualized for typical parameters (e.g. $a=0.2$, $b=0.2$, $c=5.7$). The system’s chaotic trajectory in phase space will be integrated with a fixed-step RK4 solver.
  
  \vspace{2in}
}

\medskip
\hrulefill
\medskip

\noindent
ODE workflows often involve ensembles: many solves across parameters, initial conditions,
or long time horizons. In that regime, per-call overhead to the ODE model function
—especially allocations—dominates and can make otherwise simple experiments impractically slow.

\medskip

\noindent
The Rössler ODE system is defined as
\begin{flalign*}
  \tag{Rössler} \label{eq:rossler}
  \quad \vx'(t) = \vf(\vx,\, \vp, \, t) = 
  \vect{
    -x_2 \,-\, x_3 \\
    x_1 \,+\, a x_2 \\
    b \,+\, x_3 (x_1 \,-\, c) \\
  }
    ~ : ~ \begin{cases*}
    \vx = (x_1, \, x_2, \, x_3)^\top \text{ (state variables)}\\
    \vp = (a, \, b, \, c)^\top \text{ (parameters)} 
  \end{cases*}, &&
\end{flalign*}
where cononical paramters are $a=0.2$, $b=0.2$, $c=5.7$.
The \ref{eq:rossler} system is non-stiff and exhibits chaotic dynamics, making it suitable
benchmark problem for ODE solvers. Numerical integration is done with the classical 4th-order Runge-Kutta (RK4) method - an explicit
solver with $4$-stages, leading to 4 evaluations of $\vf$ at each fixed step. We seek $\vx(t)$ for $t \in [0, T]$ subject
to IC $\vx_0=(1, 1, 1)$ and paramters $\vp=(0.1, 0.1, 15.7)$.

\medskip

\noindent
The goal is to achieve the fastest possible integration time for this system, while mainting code clarity.
C-like performance is achieved using \texttt{DifferentialEquations.jl}~\cite{DifferentialEquations.jl-2017}
from the SciML ecosystem, utilizing documented techniques for optimizing the model code $\vf$
[\cite{SciMLTutorial}, \cite{DiffEqDocsFasterODEExample} \red{Add other ref related to optimizing
julia ODE model code goes here}
].

\medskip

\noindent
\subsection*{Computational Cost:} RK4 advances $\vx_n \approx \vx(t_n) \text{ via } \vx_{n+1} = \vx_n + \frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)$.
The variable cost at stages $k_1,\ldots,k_4$ is evaluating $\vf$ at intermediate points;
which depend on the previous stage. Thus, the total flop count for final simulation time $T$ and step size $h$
is $O(N)$, where $N=T/h$ is the total number of steps. Therefore, halving the step size (thereby doubling $N$)
doubles the number of flops and should approximately double runtime, assuming overhead remains negligible
and the CPU scales linearly. The linear scaling of RK4 is a key expectation verified in our benchmarks.

\medskip

\noindent
\subsection*{Heap vs. Stack Allocation:} Heap vs. Stack Allocation: In Julia (and low-level languages like C),
data can often be allocated on the stack instead of the heap. Stack allocation is fast and has essentially no
overhead for creation or cleanup – memory is managed by the function call stack and automatically reclaimed 
when out of scope. Our benchmarks will illustrate how different coding patterns for the Rössler ODE affect 
whether memory is allocated on the heap or kept on the stack. In particular, we will see how using in-place
updates and fixed size arrays can eliminate most heap allocations by leveraging stack storage.
\footnote{``Stack allocation`` herein refers to any memory allocation that doesn't occur at runtime.
Measuring a program's stack allocation requires third party external tools.}

\medskip

\noindent

%------------------------ Bottom Column Visual  ------------------------
\td{
  \textbf{Performance Metrics and Tools:} 
  To benchmark ODE solvers, we measure:\\
  (1) runtime: wall clock time.\\
  (2) memory usage: heap allocations (allocation free => program uses stack memory)
  
  \medskip

  \textbf{Add Benchmarking Pipeline Figure} The Rössler attractor visualized
  for typical parameters (e.g. $a=0.2$, $b=0.2$, $c=5.7$).
  The system’s chaotic trajectory in phase space will be integrated with a fixed-step RK4 solver.
  
  \vspace{4in}
}

\switchcolumn

%----------------------------------------------------------------------------------------
% BEGIN: MIDDLE COLUMN
%----------------------------------------------------------------------------------------
\section*{Case Study: Optimizing the Rössler ODE System}

\noindent
We compare out-of-place and in-place Julia implementations
of the \eqref{eq:rossler} system, together with a type-stable fixed/static-size variant:
\begin{itemize}
  \item naïve out-of-place code allocates a new array at each right-hand-side call, triggering garbage collection;
  \item optimized in-place code eliminates per-call allocations for \texttt{Vector}-based states; and
  \item a \texttt{StaticArrays.jl}/\texttt{SVector} implementation enables stack allocation, often fastest for very small systems.
\end{itemize}
\textbf{Performance ladder highlights.}
  \begin{itemize}
    \item \texttt{StaticArrays} keep the three-state RHS on the stack, reducing heap pressure and GC noise.
    \item Fixed-size math improves cache locality and throughput for tight ODE kernels.
    \item \texttt{@inbounds} removes bounds checks once dimensions are known at compile time.
    \item \texttt{@inline} encourages the compiler to fuse the RHS into the solver loop, trimming call overhead.
    \item Fewer checks and calls leave the CPU focused on arithmetic in the hot loop.
  \end{itemize}
  We optimize each implementation using macros \texttt{\@inbounds}, \texttt{\@inline}, and we see
  the lowered code to understand the impact of these changes.

\medskip
\hrulefill
\medskip

\noindent
\subsection*{Results and Analysis}

% --- Figures: speedup plot ---
\noindent
\begin{minipage}{\linewidth}
\centering
\begin{minipage}[t]{0.475\linewidth} % Left figure
  \includegraphics[width=0.95\linewidth]{rk4_time_normalized_log10.png}
  {\captionsetup{hypcap=false}%
  \captionof{figure}{Solve-time speedup for Rössler RHS variants relative to the naïve out-of-place baseline `rossler\_naive`, using $\text{speedup}=\mathrm{median\_time}(\texttt{rossler\_naive})/\mathrm{median\_time}(\text{variant})$.}}
\end{minipage}
\hfill
\begin{minipage}[t]{0.475\linewidth} % Right figure
  \includegraphics[width=0.95\linewidth]{rk4_time_normalized_log10.png}
  {\captionsetup{hypcap=false}%
  \captionof{figure}{Solve-time bar chart normalized against the same `rossler\_naive` baseline, highlighting the six core ladder functions and using the speedup definition $\mathrm{median\_time}(\texttt{rossler\_naive})/\mathrm{median\_time}(\text{variant})$.}}
\end{minipage}
\end{minipage}
% --- Table placeholder: benchmark numbers ---
\begin{center}
  \begin{tabular}{lccc}
    \toprule
    \textbf{Method} & \textbf{Runtime (rel.)} & \textbf{Allocations (rel.)} & \textbf{Speedup} \\
    \midrule
    Naïve Julia      & 1.00 & 1.00 & $1.0\times$ \\
    Optimized Julia  & 0.12 & 0.05 & $8.3\times$ \\
    SciML baseline   & 0.10 & 0.04 & $10.0\times$ \\
    \bottomrule
  \end{tabular}
  {\captionsetup{hypcap=false}%
  \captionof{table}{Relative runtime, allocations and speedup, where speedup is always computed as $\mathrm{median\_time}(\texttt{rossler\_naive})/\mathrm{median\_time}(\text{variant})$ to keep the naïve out-of-place implementation as the baseline.}}
\end{center}

\medskip
\hrulefill
\medskip

\switchcolumn
%----------------------------------------------------------------------------------------
% BEGIN: THIRD COLUMN
%----------------------------------------------------------------------------------------

% ---- TODO WHAT GOES HERE? --- Conclusion comes last

%------------------------ Conclusion ------------------------
\section*{\textbf{WIP} Conclusion: Optimizing ODEs in Julia}
\td{
\noindent
Symbolic computation can automate derivations and optimizations that would otherwise
be performed manually, improving both performance and reliability.  For example, the 
Rössler system \eqref{eq:rossler} is linear in two unknowns and can be simplified by 
substitution; \texttt{ModelingToolkit.jl} can automate this process and generates 
optimized code for the resulting system.

\medskip

\noindent
By carefully crafting our Julia implementation—using in-place updates, 
static arrays and solver-aware techniques—we achieved C-like performance 
without sacrificing code clarity. Eliminating unnecessary allocations and 
choosing the right data layout allow simulation code to scale up to large problems,
be reused in future research and be shared confidently with the community.

\medskip

\noindent
Choosing the right integrator is crucial: an explicit scheme is sufficient for 
the non-stiff Rössler system, but implicit methods are necessary for stiff problems.
The SciML ecosystem provides a rich set of tools for selecting and tuning the best 
solver for your problem; don’t guess—measure with \texttt{BenchmarkTools.jl}!
}
\medskip

\noindent
%------------------------ REFERENCES ------------------------
\nocite{*}
\bibliographystyle{plain}
\bibliography{mybib}

\end{paracol}
\end{document}